SubTask 1 Add the new Arrow-aware trait
• Create a trait named QueryRunnerArrow in query_runner.rs (or the same file that holds QueryRunner).
```
#[async_trait]
pub trait QueryRunnerArrow: Send + Sync {
    async fn execute_arrow(
        &self,
        query: String,
        params: Option<Vec<Option<Bytes>>>,
        param_types: Option<Vec<Type>>,
        do_describe: bool,
        connection_id: u64,
    ) -> datafusion::error::Result<ArrowQueryResult>;
}
```

ArrowQueryResult is the (Vec<RecordBatch>, Arc<Schema>) tuple.

• Implement QueryRunnerArrow for DirectQueryRunner. Return the batches and schema that you already extract inside on_query, skipping any stringification.
• Implement QueryRunnerArrow for RouterQueryRunner. Return the (batches, schema) coming straight from dispatch_query.
• Do not touch the old QueryRunner trait; keep both traits side-by-side.
• cargo check must still pass.

SubTask 2 Integrate Arrow path in RiffqProcessor::do_query behind a feature gate
• Add a Cargo feature called zero_copy in Cargo.toml; default to false.
• In do_query wrap the new logic with #[cfg(feature = "zero_copy")].
– Inside the gate call self.query_runner.execute_arrow( … ).
– Feed the result into arrow_to_pg_rows to obtain the stream for QueryResponse.
• Keep the existing string-based branch under #[cfg(not(feature = "zero_copy"))].
• cargo check --no-default-features and cargo check --features zero_copy must both succeed.

Subtask 3 Apply the same gated switch to the extended protocol handlers
• In MyExtendedQueryHandler::do_query add the identical cfg split:
– zero_copy branch uses execute_arrow plus arrow_to_pg_rows.
– Default branch keeps the old string code.
• In MyExtendedQueryHandler::do_describe_portal add the zero_copy branch that calls execute_arrow with do_describe = true and builds the DescribePortalResponse from schema.fields(). Fall back to the current logic when the feature is off.
• Re-run both compile commands from SubTask 2 to confirm.








